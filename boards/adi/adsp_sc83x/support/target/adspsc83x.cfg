# Analog Devices ADSP-SC83x
#
# Copyright (C) 2023 Analog Devices, Inc. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0
#
# This software is proprietary to Analog Devices, Inc. and its licensors.

source [find mem_helper.tcl]
source [find target/adspsc83x.tcl]

set _CHIPNAME adspsc83x

# allow ability to skip reset
global SKIP_RESET
set SKIP_RESET 0

# allow the option for core reset
global ENABLE_CORE_RESET
set ENABLE_CORE_RESET 0

# used to tell if the SHARC FX has gone through gdb-attach
# if this stays 0 then it is an M33 only connection and
# RCU_MSG is used to release the core
global SFX_ATTACHED
set SFX_ATTACHED 0

# used for heterogeneous connection to let the secondary core (m33)
# know the system reset has already been done
global SYSTEM_RESET_COMPLETE
set SYSTEM_RESET_COMPLETE 0

# UserKey

# Uncomment the following 8 lines and change 0x00000000 to key values
#set USERKEY0 0x00000000
#set USERKEY1 0x00000000
#set USERKEY2 0x00000000
#set USERKEY3 0x00000000
#set USERKEY4 0x00000000
#set USERKEY5 0x00000000
#set USERKEY6 0x00000000
#set USERKEY7 0x00000000

if { [info exists USERKEY0] } {
	set  _USERKEY0 $USERKEY0
} else {
	set  _USERKEY0 0x00000000
}

if { [info exists USERKEY1] } {
	set  _USERKEY1 $USERKEY1
} else {
	set  _USERKEY1 0x00000000
}

if { [info exists USERKEY2] } {
	set  _USERKEY2 $USERKEY2
} else {
	set  _USERKEY2 0x00000000
}

if { [info exists USERKEY3] } {
	set  _USERKEY3 $USERKEY3
} else {
	set  _USERKEY3 0x00000000
}

if { [info exists USERKEY4] } {
	set  _USERKEY4 $USERKEY4
} else {
	set  _USERKEY4 0x00000000
}

if { [info exists USERKEY5] } {
	set  _USERKEY5 $USERKEY5
} else {
	set  _USERKEY5 0x00000000
}

if { [info exists USERKEY6] } {
	set  _USERKEY6 $USERKEY6
} else {
	set  _USERKEY6 0x00000000
}

if { [info exists USERKEY7] } {
	set  _USERKEY7 $USERKEY7
} else {
	set  _USERKEY7 0x00000000
}

# CoreSight Debug Access Port (DAP)
if { [info exists DAP_TAPID ] } {
	set _DAP_TAPID $DAP_TAPID
} else {
	set _DAP_TAPID 0x4ba06477
}

# debug control register
set TAPC_DBG_CTL 0x31131000

jtag newtap $_CHIPNAME cpu -irlen 4 -expected-id $_DAP_TAPID -disable
jtag configure $_CHIPNAME.cpu -event tap-enable "adjc_enable_dap $_CHIPNAME.adjc"

# ADI JTAG Controller
if { [info exists ADJC_TAPID ] } {
	set _ADJC_TAPID $ADJC_TAPID
} else {
	set _ADJC_TAPID 0x0282c0cb
}

jtag newtap $_CHIPNAME adjc -irlen 5 -expected-id $_ADJC_TAPID

# Once the JRC is up, enable our TAPs
jtag configure $_CHIPNAME.adjc -event setup "jtag tapenable $_CHIPNAME.cpu"

# The following order of target creation must be maintained to allow the SHARC-FX core to
# reset first since the reset routines are called in the same order as the target creation.
# This reset sequence is required for successful SPI flash programming.
# GDB target:  Sharc FX, using DAP
set _TARGETNAME $_CHIPNAME.cpu
dap create $_CHIPNAME.dap -chain-position $_TARGETNAME

#
# sharc fx xtensa target
#
set _TARGETNAME_SFX $_CHIPNAME.sharcfx
target create $_TARGETNAME_SFX xtensa -dap $_CHIPNAME.dap -dbgbase 0x80014000

# Unless USE_CTI is set to 0, CTI is used to halt and restart the system
# peripherials whenever the SHARC-FX is halted and restarted
if { [info exists USE_CTI] } {
	set _USE_CTI $USE_CTI
} else {
	set _USE_CTI 1
}
if { $_USE_CTI != 0 } {
	log_info "halt and restart using CTI"

	$_TARGETNAME_SFX configure -restart-cti-reg-addr 0x8000d01c -restart-cti-channel 1 -halt-cti-channel 0
}

source [find target/xtensa-core-adspsc83x.cfg]

#
# Cortex-M33 target
#
set _TARGETNAME_M33 $_CHIPNAME.m33
target create $_TARGETNAME_M33 cortex_m -dap $_CHIPNAME.dap

# handle command that allows skipping a reset on attach
proc skip_reset {} {
	global SKIP_RESET
	global ENABLE_CORE_RESET

# clear in case it was set by the booting core
	set ENABLE_CORE_RESET 0
	set SKIP_RESET 1
}

# handle command that allows using a core reset
proc enable_core_reset {} {
	global ENABLE_CORE_RESET
	global SKIP_RESET

# clear in case it was set by the booting core
	set SKIP_RESET 0
	set ENABLE_CORE_RESET 1
}

# core reset
proc adspsc83x_m33_core_reset {} {
	global _CHIPNAME

	set rcu_ctl       0x3108c000
	set rcu_stat      [expr {$rcu_ctl + 0x4}]
	set rcu_crctl     [expr {$rcu_ctl + 0x8}]
	set rcu_crstat    [expr {$rcu_ctl + 0xC}]
	set rcu_bcode     [expr {$rcu_ctl + 0x28}]
	set rcu_svect2    [expr {$rcu_ctl + 0x34}]

	# Read BMODE from RCU0_STAT
	set data [$_CHIPNAME.dap readmem 2 $rcu_stat]
	set bootmode [expr {($data >> 8) & 0xf}]
	log_debug "Boot Mode $bootmode"

	log_info "starting Cortex-m33 core reset ..."

# Set HALT (bit 2)
# *pREG_RCU0_BCODE = 0x4
	mww $rcu_bcode 0x4

# Set core to entry points
# *pREG_RCU0_SVECT2 = 0x701
	mww $rcu_svect2 0x701

# clear CRn bit in CRSTAT register( bit is W1C )
# *pREG_RCU0_CRSTAT = 0x4
	mww $rcu_crstat 0x4

# set bit 2 in CRCTL to assert core 2 (cortex m33) reset signal
# *pREG_RCU0_CRCTL = 0x4
	$_CHIPNAME.dap writemem 2 $rcu_crctl 0x4

# give time for reset to take affect
	sleep 1000

# Wait till Core 2 is in reset
	set data 0
	set retry 0
	while { [expr {$data & 0x4}] == 0 } {
		set data [$_CHIPNAME.dap readmem 2 $rcu_crstat]
		set retry [expr {$retry + 1}]
		if { $retry > 20 } break;
	}
	if { $retry > 20 } {
		set msg [format 0x%08x $data]
		log_error "Core was not put in reset"
	}

# clear CRCTL to deassert core 2 reset signal
	$_CHIPNAME.dap writemem 2 $rcu_crctl 0

# clear CRSTAT bit 1( bit is W1C )
	$_CHIPNAME.dap writemem 2 $rcu_crstat 0x4

# small delay to give reset time to clear
	sleep 300

	log_info "Cortex-m33 core reset complete..."
}

# core reset
proc adspsc83x_sharcfx_core_reset {} {
	global _CHIPNAME

	set rcu_ctl       0x3108c000
	set rcu_stat      [expr {$rcu_ctl + 0x4}]
	set rcu_crctl     [expr {$rcu_ctl + 0x8}]
	set rcu_crstat    [expr {$rcu_ctl + 0xC}]
	set rcu_bcode     [expr {$rcu_ctl + 0x28}]
	set rcu_svect1    [expr {$rcu_ctl + 0x30}]

# Read BMODE from RCU0_STAT
	set data [$_CHIPNAME.dap readmem 2 $rcu_stat]
	set bootmode [expr {($data >> 8) & 0xf}]
	log_info "Boot Mode $bootmode"

	log_info "starting SHARC FX core reset ..."

# Set HALT (bit 2)
# *pREG_RCU0_BCODE = 0x4
	mww $rcu_bcode 0x4

# Set core to entry points
# *pREG_RCU0_SVECT1 = 0x202000E4
	mww $rcu_svect1 0x202000E4

# clear CRn bit in CRSTAT register( bit is W1C )
# *pREG_RCU0_CRSTAT = 0x2
	mww $rcu_crstat 0x2

# turn polling off
	poll off

# set bit 1 in CRCTL to assert core 1 reset signal
# *pREG_RCU0_CRCTL = 0x2
	$_CHIPNAME.dap writemem 2 $rcu_crctl 0x2

# give time for reset to take affect
	sleep 1000

# Wait till Core 1 is in reset
	set data 0
	set retry 0
	while { [expr {$data & 0x2}] == 0 } {
		set data [$_CHIPNAME.dap readmem 2 $rcu_crstat]
		set retry [expr {$retry + 1}]
		if { $retry > 20 } break;
	}
	if { $retry > 20 } {
		set msg [format 0x%08x $data]
		log_error "Core was not put in reset"
	}

# clear CRCTL to deassert core 1 reset signal
	$_CHIPNAME.dap writemem 2 $rcu_crctl 0

# clear CRSTAT bit 1( bit is W1C )
	$_CHIPNAME.dap writemem 2 $rcu_crstat 0x2

# small delay to give reset time to clear
	sleep 300

	poll on

	log_info "SHARC FX core reset complete..."
}

proc adspsc83x_system_reset {} {
	global _CHIPNAME
	global SYSTEM_RESET_COMPLETE

	set rcu_ctl     0x3108c000
	set rcu_stat    [expr {$rcu_ctl + 0x4}]
	set rcu_bcode   [expr {$rcu_ctl + 0x28}]
	set rcu_msg     [expr {$rcu_ctl + 0x6c}]

	set cti3_cticontrol  0x3110d000
	set cti3_ctiapppulse [expr {$cti3_cticontrol + 0x1c}]
	set cti3_ctiouten2   [expr {$cti3_cticontrol + 0xa8}]
	set cti3_lar         [expr {$cti3_cticontrol + 0xfb0}]

	log_info "start system reset..."

# Clear REG_RCU0_MSG
# *pREG_RCU0_MSG = 0x0
	mww $rcu_msg 0

	log_debug "Deassert RSTOUT in REG_RCU0_CTL"
# Deassert RSTOUT in REG_RCU0_CTL
# *pREG_RCU0_CTL |= 0x4
	set value 0
	set value [$_CHIPNAME.dap readmem 2 $rcu_ctl]
	set value [expr {$value | 0x4}]
	mww $rcu_ctl $value

# Clear REG_RCU0_STAT
	mww $rcu_stat 0x7000d

# Set HALT (bit 2)
	mww $rcu_bcode 0x4

# Use CTI to do system reset
# Unlock CTI3 (System CTI)
	log_debug "Unlock CTI3 (System CTI)..."
	mww $cti3_lar 0xC5ACCE55

# Enable CTI3 (System CTI)
	log_debug "Enable CTI3 (System CTI)..."
	mww $cti3_cticontrol 0x1

# Connect CTITRIGOUT[2] of CTI3 to channel 2
	log_debug "Connect CTITRIGOUT of CTI3 to channel 2..."
	mww $cti3_ctiouten2 0x4

	log_debug "system reset asserted"
	mww $cti3_ctiapppulse 0x4

	log_debug "give time to reset"
	sleep 2000

# Wait till Core 1 is idle
# while((*pREG_RCU0_MSG & BITM_RCU_MSG_C1IDLE) == 0);
	set data 0
	set retry 0
	while { [expr {$data & 0x200}] == 0 } {
		set data [$_CHIPNAME.dap readmem 2 $rcu_msg]
		set retry [expr {$retry + 1}]
		if { $retry > 20 } break;
	}
	if { $retry > 20 } {
		set msg [format 0x%08x $data]
		log_error "BCODE.HALT failed (REG_RCU0_MSG $msg)"
	}

# Now BOOT is done
	log_info "system reset complete"

# clear REG_RCU0_MSG
	$_CHIPNAME.dap writemem 2 $rcu_msg 0x0

# clear REG_RCU0_BCODE
	$_CHIPNAME.dap writemem 2 $rcu_bcode 0x0

# Disable CTI3 (System CTI)
	$_CHIPNAME.dap writemem 2 $cti3_cticontrol 0x0

# With a heterogeneous connection, only do this once
# There is no need to do system reset again through
# the secondary core (Cortex-m33)
	set SYSTEM_RESET_COMPLETE 1
}

proc adspsc83x_sharcfx_reset {} {
	global ENABLE_CORE_RESET

	if { $ENABLE_CORE_RESET == 1 } {
		adspsc83x_sharcfx_core_reset
	} else {
		adspsc83x_system_reset
	}
}

$_TARGETNAME_SFX configure -event examine-start {
	global _CHIPNAME
	global TAPC_DBG_CTL

# enable debug
# [23]- SPIDEN for Cortex M33
# [22]- SPNIDEN for Cortex M33
# [21]- NIDEN for Cortex M33
# [20]- DBGEN for Cortex M33
# [19]- SPIDEN for SHARC core
# [18]- SPNIDEN for SHARC core
# [17]- NIDEN for SHARC core
# [16]- DBGEN for SHARC core
# [12]- NIDEN for CTISYS
# [11]- DBGEN for CTISYS
# [0] - SPIDEN for DAP
	log_debug "Enable debug..."
	$_CHIPNAME.dap writemem 2 $TAPC_DBG_CTL 0xFF1801
}

$_TARGETNAME_SFX configure -event reset-assert {
	halt
	adspsc83x_sharcfx_reset
}

$_TARGETNAME_SFX configure -event gdb-attach {
	global SKIP_RESET
	global SFX_ATTACHED

if {[$_TARGETNAME_SFX curstate] == "running"} { halt }

	if { $SKIP_RESET == 0 } {
		adspsc83x_sharcfx_reset
		halt
	}

	if { $_USE_CTI != 0 } {
		adspsc83x_configure_cti
	}

# let M33 know that the SFX has attached
	set SFX_ATTACHED 1
}

$_TARGETNAME_M33 configure -event examine-start {
	global _CHIPNAME
	global TAPC_DBG_CTL

# enable debug
# [23]- SPIDEN for Cortex M33
# [22]- SPNIDEN for Cortex M33
# [21]- NIDEN for Cortex M33
# [20]- DBGEN for Cortex M33
# [19]- SPIDEN for SHARC core
# [18]- SPNIDEN for SHARC core
# [17]- NIDEN for SHARC core
# [16]- DBGEN for SHARC core
# [12]- NIDEN for CTISYS
# [11]- DBGEN for CTISYS
# [0] - SPIDEN for DAP
	log_debug "Enable debug 2..."
	$_CHIPNAME.dap writemem 2 $TAPC_DBG_CTL 0xFF1801
}

$_TARGETNAME_M33 configure -event reset-assert {
# Polling is off during reset by default set in target.c.
# When attempting to halt, the state is unknown resulting in a warning.
# Turn polling on in order to retrieve the state before halting the core
	poll on

# poll the target state
	poll

# system reset has been performed so the core just has to halt
	halt
}

$_TARGETNAME_M33 configure -event gdb-attach {
	global _CHIPNAME
	global SKIP_RESET
	global ENABLE_CORE_RESET
	global SYSTEM_RESET_COMPLETE
	global SFX_ATTACHED

	set rcu_base     0x3108c000
	set rcu_msg_set  [expr {$rcu_base + 0x70}]

	if { $SKIP_RESET == 0 } {
		if { $ENABLE_CORE_RESET == 1 } {
			adspsc83x_m33_core_reset
		} else {
			if { $SYSTEM_RESET_COMPLETE == 0 } {
				adspsc83x_system_reset
			}
		}
	}
	halt

# Cortex M33 only connection so release the core
	if { $SFX_ATTACHED == 0 } {
# [20] - Core 2 Activated
		$_CHIPNAME.dap writemem 2 $rcu_msg_set 0x00100000
	}

	arm semihosting enable
}

reset_config trst_only

gdb_report_register_access_error enable

# GDB will try to probe the flash if memory map is left enabled
gdb_memory_map disable
